# 3.3 コレクション

> **本節の目標**
>
> データをひとまとめにするものを**コレクション**といいます。コレクションの例として、Rのベクタ/リスト、Pythonのリスト/アレイ/シリーズ/辞書の使い方を確認します。

> **用語について**
> 
> コレクションを「コンテナ」ということもあります。2.3節で紹介したDockerのコンテナとは別物です。
> データフレームというコレクションを、3.4節で別に紹介します。

## 3.3.0 導入：コレクションとは

### コレクションの重要性

これまでの節では、一つひとつの値（数値、文字列、論理値）を扱ってきました。しかし、実際のデータサイエンスでは、**複数のデータをまとめて扱う**場面が圧倒的に多いです。

例えば：
- 10人の学生の試験成績
- 1年間の月別売上データ
- アンケートの回答リスト
- ユーザーIDと名前の対応表

このような「複数のデータのまとまり」を効率的に管理するのが**コレクション**です。

### 本節で学ぶこと

この節では、以下のコレクションを学びます：

#### 1次元データ
- **R**: ベクタ（vector）
- **Python**: リスト（list）、アレイ（array）、シリーズ（series）

#### キー・バリュー型
- **R**: 名前付きリスト
- **Python**: 辞書（dictionary）

#### 重要な違い
- RとPythonでのインデックスの違い（1始まり vs 0始まり）
- コピーと参照の違い

### なぜコレクションが必要なのか

**例：10人の試験成績を扱う場合**

❌ **コレクションを使わない場合**（非効率）:
```python
score1 = 85
score2 = 92
score3 = 78
# ... 10個の変数が必要
```

✅ **コレクションを使う場合**（効率的）
```python
scores = [85, 92, 78, 88, 95, 73, 89, 91, 76, 84]
```

コレクションを使えば：
- データをまとめて管理できる
- 繰り返し処理が簡単
- 一括で計算できる
- コードがシンプルになる

### GitHub Copilotの準備

本節では、GitHub Copilotを活用してコレクションの操作を効率的に学びます。

#### Copilotが有効か確認

VS Codeの右下に **Copilotのアイコン** が表示されていることを確認してください。

#### Copilot Chatの起動

- **方法1**: `Ctrl + Shift + P` → "GitHub Copilot: Chat" を選択
- **方法2**: サイドバーのチャットアイコンをクリック

#### 本節での使い方

各サブセクションの最後に **💡 GitHub Copilot活用ガイド** があります。そこに記載されたプロンプト例を試してみましょう。

#### 基本的な心構え

✅ **やるべきこと**
1. まず教材で概念を理解する
2. サンプルコードを自分で実行する
3. 理解した上でCopilotに質問する
4. 生成されたコードを必ず確認・理解する

❌ **避けるべきこと**
- 教材を読まずにCopilotに丸投げ
- 生成されたコードを理解せずにコピペ
- Copilotの回答を鵜呑みにする

**Copilotは「学習パートナー」です。協働しながら学びましょう！**

## 3.3.1 1次元データ

同じ種類（型）のデータをひとまとめにしたものを、Rでは**ベクタ**（ベクトル）、Pythonでは**リスト**といいます。名前を使い分けるのは面倒なので、これらをまとめて本書では**1次元データ**といいます。

> **用語について**
>
> ここで想定しているのは、計算機科学では**ベクタ**といわれるコレクションです。
> 
> **Python注**: リストには型の異なるデータを入れられます（3.3.3項を参照）。
>
> foo, bar, bazというのは、仮の名前としてよく使われる語です。

### 1次元データの作成

例として、`"foo"`, `"bar"`, `"baz"`という3個の文字列をひとまとめにして、名前を付けます。

- **R**: `c()`の中に要素を並べる
- **Python**: `[]`の中に要素を並べる

#### サンプルプログラム：基本的な1次元データの作成

**sample01_vector_basic.R**

```r
# 1次元データ（ベクタ）の作成
x <- c("foo", "bar", "baz")

# 結果を表示
print(x)
```

**実行方法**
```bash
$ Rscript sample01_vector_basic.R
```

**期待される出力**
```
[1] "foo" "bar" "baz"
```

---

**sample01_list_basic.py**

```python
# 1次元データ（リスト）の作成
x = ['foo', 'bar', 'baz']

# 結果を表示
print(x)
```

**実行方法**
```bash
$ python sample01_list_basic.py
```

**期待される出力**
```
['foo', 'bar', 'baz']
```

### 要素数の取得

作成した1次元データの要素数を取得します。

- **R**: `length()`関数を使用
- **Python**: `len()`関数を使用

#### サンプルプログラム：要素数の確認

**sample02_vector_length.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# 要素数を取得
n <- length(x)

# 結果を表示
print(paste("要素数:", n))
```

**期待される出力**
```
[1] "要素数: 3"
```

---

**sample02_list_length.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# 要素数を取得
n = len(x)

# 結果を表示
print(f"要素数: {n}")
```

**期待される出力**
```
要素数: 3
```

### 要素へのアクセス

角括弧`[]`を使って、指定した番号の要素を取り出します。

⚠️ **重要な違い**
- **R**: インデックスは **1から** 始まる
- **Python**: インデックスは **0から** 始まる

例として、`"bar"`を取り出してみます。

#### サンプルプログラム：要素の取り出し

**sample03_vector_access.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# 2番目の要素を取り出す（Rは1から数える）
element <- x[2]

# 結果を表示
print(paste("2番目の要素:", element))
```

**期待される出力**
```
[1] "2番目の要素: bar"
```

---

**sample03_list_access.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# 2番目の要素を取り出す（Pythonは0から数える）
element = x[1]

# 結果を表示
print(f"2番目の要素: {element}")
```

**期待される出力**
```
2番目の要素: bar
```

### 要素の更新

角括弧を使って要素を更新できます。

#### サンプルプログラム：要素の更新

**sample04_vector_update.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# 2番目の要素を更新
x[2] <- "BAR"

# 結果を表示
print("更新後:")
print(x)

# 元に戻す
x[2] <- "bar"
print("元に戻した後:")
print(x)
```

**期待される出力**
```
[1] "更新後:"
[1] "foo" "BAR" "baz"
[1] "元に戻した後:"
[1] "foo" "bar" "baz"
```

---

**sample04_list_update.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# 2番目の要素を更新
x[1] = 'BAR'

# 結果を表示
print("更新後:")
print(x)

# 元に戻す
x[1] = 'bar'
print("元に戻した後:")
print(x)
```

**期待される出力**
```
更新後:
['foo', 'BAR', 'baz']
元に戻した後:
['foo', 'bar', 'baz']
```

### 負のインデックス

角括弧の中が負の場合、RとPythonで動作が異なります。

- **R**: 指定した要素を**削除した**結果のベクタを返す
- **Python**: 後ろから数えた位置の要素を返す

#### サンプルプログラム：負のインデックス

**sample05_vector_negative.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# 2番目の要素を除いた結果
result <- x[-2]

# 結果を表示
print("2番目を除いた結果:")
print(result)

# 元のxは変わらない
print("元のx:")
print(x)
```

**期待される出力**
```
[1] "2番目を除いた結果:"
[1] "foo" "baz"
[1] "元のx:"
[1] "foo" "bar" "baz"
```

---

**sample05_list_negative.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# 後ろから2番目の要素
element = x[-2]

# 結果を表示
print(f"後ろから2番目の要素: {element}")
```

**期待される出力**
```
後ろから2番目の要素: bar
```

### 要素の追加

新しい要素を追加して、新しい1次元データを作ります。

⚠️ **重要**: この操作では元の1次元データは変わりません。

#### サンプルプログラム：要素の追加（新規作成）

**sample06_vector_append.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# 新しい要素を追加した新しいベクタを作成
y <- c(x, "qux")

# 結果を表示
print("新しいベクタy:")
print(y)

print("元のベクタx（変わらない）:")
print(x)
```

**期待される出力**
```
[1] "新しいベクタy:"
[1] "foo" "bar" "baz" "qux"
[1] "元のベクタx（変わらない）:"
[1] "foo" "bar" "baz"
```

**sample06_list_append.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# 新しい要素を追加した新しいリストを作成
y = x + ['qux']

# 結果を表示
print("新しいリストy:")
print(y)

print("元のリストx（変わらない）:")
print(x)
```

**期待される出力**
```
新しいリストy:
['foo', 'bar', 'baz', 'qux']
元のリストx（変わらない）:
['foo', 'bar', 'baz']
```

### 元の1次元データを更新

元の1次元データ自体に要素を追加することもできます。

#### サンプルプログラム：元のデータを更新

**sample07_vector_update_inplace.R**

```r
# ベクタの作成
x <- c("foo", "bar", "baz")

# xを更新
x <- c(x, "qux")

# 結果を表示
print("更新後のx:")
print(x)
```

**期待される出力**
```
[1] "更新後のx:"
[1] "foo" "bar" "baz" "qux"
```

---

**sample07_list_update_inplace.py**

```python
# リストの作成
x = ['foo', 'bar', 'baz']

# xを更新（方法1: +演算子）
x = x + ['qux']

# 結果を表示
print("方法1（+ 演算子）:")
print(x)

# リストを元に戻す
x = ['foo', 'bar', 'baz']

# xを更新（方法2: appendメソッド）
x.append('qux')

# 結果を表示
print("方法2（appendメソッド）:")
print(x)
```

**期待される出力**
```
方法1（+ 演算子）:
['foo', 'bar', 'baz', 'qux']
方法2（appendメソッド）:
['foo', 'bar', 'baz', 'qux']
```

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

1次元データの基本操作（作成、アクセス、更新、追加）を学びました。これらの操作は、データサイエンスの基礎となる重要なスキルです。GitHub Copilotを使って、様々なパターンの1次元データ操作を練習してみましょう。

Copilotは、あなたが書いたコメントやコードの文脈から、次に書くべきコードを提案してくれます。まずは簡単なプロンプトから始めて、徐々に複雑な操作に挑戦しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的なリスト操作 [★☆☆]

**Copilot Chatに入力**
```
Pythonで、曜日名（"月曜日"から"日曜日"）のリストを作成し、
その要素数を表示し、3番目の要素を取り出すコードを書いてください。
初心者向けにコメント付きで。
```

**期待される動作**
- 7つの曜日名を含むリストが生成される
- `len()`で要素数を取得するコードが含まれる
- インデックス`[2]`で3番目（水曜日）を取得するコードが含まれる

**やってみよう**
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを新しいファイル（例：`exercise_weekdays.py`）にコピー
3. `python exercise_weekdays.py`で実行して動作確認
4. コード内のインデックスを変えて、別の曜日を取得してみる

---

#### プロンプト例2: データの更新と追加 [★★☆]

**Copilot Chatに入力**
```
Rで、1から5の数値ベクタを作成し、
3番目の要素を10に更新し、
最後に6を追加するコードを書いてください。
各ステップで結果を表示してください。
```

**期待される動作**
- `c(1, 2, 3, 4, 5)`でベクタを作成
- `x[3] <- 10`で更新
- `c(x, 6)`で要素を追加
- 各ステップで`print()`が含まれる

**やってみよう**
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを`exercise_update.R`として保存
3. `Rscript exercise_update.R`で実行
4. 更新する位置や追加する値を変えて実験してみる

#### プロンプト例3: RとPythonの違いを確認 [★★☆]

**Copilot Chatに入力**
```
RとPythonで、["A", "B", "C", "D"]という4要素のデータを作成し、
負のインデックス -2 を使って要素にアクセスした結果を比較するコードを書いてください。
両方の言語で結果がどう違うか分かるようにしてください。
```

**期待される動作**
- Rでは`x[-2]`が要素を除いた結果を返すコードが生成される
- Pythonでは`x[-2]`が後ろから2番目の要素を返すコードが生成される
- 両方の結果を表示するコードが含まれる

**やってみよう**
1. Copilot Chatに上記のプロンプトを入力
2. RコードとPythonコードをそれぞれ別ファイルに保存
3. 両方を実行して結果を比較
4. 他のインデックス（-1, -3など）でも試してみる

---

### 📚 Copilot活用のコツ

1. **コメントを先に書く**
   
   コードを書く前に、日本語でやりたいことをコメントとして書くと、Copilotが適切なコードを提案してくれます。
   
   ```python
   # 果物のリストを作成
   # ← ここでTabキーを押すと、Copilotがコードを提案
   ```

2. **段階的に書く**
   
   一度に全部を書こうとせず、1行ずつ書いて確認しましょう。Copilotの提案を見て、理解できたら採用します。

3. **生成されたコードを必ず理解する**
   
   Copilotが提案したコードをそのまま使う前に：
   - 各行が何をしているか確認
   - 分からない部分はCopilot Chatで質問
   - 実行して期待通りの結果か確認

4. **実験する**
   
   Copilotに「他の方法はありますか？」と聞いてみましょう。同じ処理でも複数の書き方があることを学べます。

---

### ⚠️ 注意事項

- **AIは完璧ではない**: Copilotの提案が常に正しいとは限りません。必ず自分で確認しましょう。
- **理解が第一**: コピペして動いても、理解していなければ応用できません。
- **検証する習慣**: 生成されたコードを実行して、本当に期待通りか確認しましょう。
- **自分で考える**: まず自分で考え、詰まったらCopilotに聞くという順序が大切です。

---

### 🎓 推奨される学習の流れ

```
1. 教材を読んで概念を理解
   ↓
2. サンプルプログラムを自分で実行
   ↓
3. 自分で似たようなプログラムを書いてみる
   ↓
4. 困ったらCopilotに聞く
   ↓
5. 生成されたコードを理解して実験
   ↓
6. 練習問題で定着
```

**大切なのは「AIと協働する」姿勢です。丸投げではなく、一緒に学ぶパートナーとして活用しましょう！**

---

## 3.3.1.1 等間隔の数値からなる1次元データ

データサイエンスでは、等間隔の数値データを扱うことがよくあります。例えば：
- 1から100までの整数
- 0から1まで0.1刻みの小数
- 時系列データの時刻

これらを手動で入力するのは大変なので、便利な関数が用意されています。

### 基本的な連続整数

まずは最も基本的な、連続する整数のデータを作ります。

⚠️ **重要な違い**:
- **R**: `1:5`は1から5まで（5を含む）
- **Python**: `range(5)`は0から4まで（5を含まない）

これは、Rが1始まり、Pythonが0始まりという言語の特性に合わせた設計です。

#### サンプルプログラム：連続整数の生成

**sample08_seq_basic.R**

```r
# 1から5までの整数ベクタ
x <- 1:5

# 結果を表示
print("1から5までの整数:")
print(x)

# 要素数を確認
print(paste("要素数:", length(x)))
```

**期待される出力**:
```
[1] "1から5までの整数:"
[1] 1 2 3 4 5
[1] "要素数: 5"
```

---

**sample08_range_basic.py**

```python
# 0から4までの整数リスト
x = list(range(5))

# 結果を表示
print("0から4までの整数:")
print(x)

# 要素数を確認
print(f"要素数: {len(x)}")
```

**期待される出力**:
```
0から4までの整数:
[0, 1, 2, 3, 4]
要素数: 5
```

> **Python注**: `range(5)`の結果を`list()`で変換しています。変換しなくても多くの場面でリストと同じように使えますが、ここではわかりやすさのためにリストに変換しています。

### 開始値と終了値を指定

開始値と終了値を指定して、等間隔の数値データを作ります。

#### サンプルプログラム：偶数の生成

**sample09_seq_even.R**

```r
# 0以上10以下の偶数
even_numbers <- seq(from = 0, to = 10, by = 2)

# 結果を表示
print("0から10までの偶数:")
print(even_numbers)
```

**期待される出力**:
```
[1] "0から10までの偶数:"
[1]  0  2  4  6  8 10
```

---

**sample09_range_even.py**

```python
# 0以上10以下の偶数
even_numbers = list(range(0, 11, 2))

# 結果を表示
print("0から10までの偶数:")
print(even_numbers)
```

**期待される出力**:
```
0から10までの偶数:
[0, 2, 4, 6, 8, 10]
```

⚠️ **Python注**: `range(0, 11, 2)`の2番目の引数（11）は結果に含まれません。10を含めるために11を指定しています。

### 小数の等間隔データ

整数でない等間隔データを作成する場合は、専用の関数を使います。

#### サンプルプログラム：小数の等間隔データ

**sample10_seq_decimal.R**

```r
# 0から1まで間隔0.5
x <- seq(from = 0, to = 1, by = 0.5)

# 結果を表示
print("0から1まで0.5刻み:")
print(x)
```

**期待される出力**:
```
[1] "0から1まで0.5刻み:"
[1] 0.0 0.5 1.0
```

---

**sample10_arange_decimal.py**

```python
import numpy as np

# 0から1まで間隔0.5
x = np.arange(0, 1.1, 0.5)

# 結果を表示
print("0から1まで0.5刻み:")
print(x)
```

**期待される出力**:
```
0から1まで0.5刻み:
[0.  0.5 1. ]
```

⚠️ **Python注**: 
- 引数が小数の場合は`np.arange`を使います
- 1.0を含めるために終了値を1.1にしています（浮動小数点の誤差に注意）

### 要素数を指定した等間隔データ

範囲と要素数を指定して、自動的に間隔を計算させることもできます。

#### サンプルプログラム：要素数指定

**sample11_seq_length.R**

```r
# 0から100までを5等分
x <- seq(from = 0, to = 100, length.out = 5)

# 結果を表示
print("0から100までを5等分:")
print(x)
```

**期待される出力**:
```
[1] "0から100までを5等分:"
[1]   0  25  50  75 100
```

---

**sample11_linspace.py**

```python
import numpy as np

# 0から100までを5等分
x = np.linspace(0, 100, 5)

# 結果を表示
print("0から100までを5等分:")
print(x)
```

**期待される出力**:
```
0から100までを5等分:
[  0.  25.  50.  75. 100.]
```

### 同じ値を複数個並べる

同じ値を繰り返したデータを作成する場合は、次の方法が簡単です。

#### サンプルプログラム：値の繰り返し

**sample12_rep.R**

```r
# 10を5個並べる
x <- rep(x = 10, times = 5)

# 結果を表示
print("10を5個:")
print(x)
```

**期待される出力**:
```
[1] "10を5個:"
[1] 10 10 10 10 10
```

---

**sample12_repeat.py**

```python
# 10を5個並べる
x = [10] * 5

# 結果を表示
print("10を5個:")
print(x)
```

**期待される出力**:
```
10を5個:
[10, 10, 10, 10, 10]
```

### 実用例：時系列データの準備

等間隔データは、グラフのx軸やシミュレーションなどでよく使います。

#### サンプルプログラム：実用例

**sample13_practical_seq.R**

```r
# 0から2πまで100個の点
x <- seq(from = 0, to = 2 * pi, length.out = 100)

# sin関数の値を計算
y <- sin(x)

# 最初の5個を表示
print("xの最初の5個:")
print(head(x, 5))

print("対応するsin(x)の値:")
print(head(y, 5))
```

**期待される出力**:
```
[1] "xの最初の5個:"
[1] 0.00000000 0.06346652 0.12693304 0.19039955 0.25386607
[1] "対応するsin(x)の値:"
[1] 0.00000000 0.06342392 0.12659245 0.18925124 0.25114773
```

---

**sample13_practical_linspace.py**

```python
import numpy as np

# 0から2πまで100個の点
x = np.linspace(0, 2 * np.pi, 100)

# sin関数の値を計算
y = np.sin(x)

# 最初の5個を表示
print("xの最初の5個:")
print(x[:5])

print("対応するsin(x)の値:")
print(y[:5])
```

**期待される出力**:
```
xの最初の5個:
[0.         0.06346652 0.12693304 0.19039955 0.25386607]
対応するsin(x)の値:
[0.         0.06342392 0.12659245 0.18925124 0.25114773]
```

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

等間隔の数値データ生成は、データサイエンスの多くの場面で必要になります。実験データのサンプリング、グラフの軸、シミュレーションなど、応用範囲は広いです。Copilotを使って、様々なパターンの数値データ生成を練習しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的な数値範囲の生成 [★☆☆]

**Copilot Chatに入力**:
```
Pythonで、1から100までの奇数のリストを作成するコードを書いてください。
range関数を使って、初心者向けにコメント付きで。
```

**期待される動作**:
- `range(1, 101, 2)`を使ったコードが生成される
- 結果を`list()`で変換するコードが含まれる
- 各部分に日本語コメントが付く

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行して、奇数が正しく生成されることを確認
3. 偶数のリストに変更してみる（開始値や刻み幅を調整）

---

#### プロンプト例2: 小数を含む等間隔データ [★★☆]

**Copilot Chatに入力**:
```
Rで、0から1までを0.1刻みで分割した数値ベクタを作成し、
各値の2乗を計算して表示するコードを書いてください。
```

**期待される動作**:
- `seq(0, 1, 0.1)`でベクタを作成
- ベクトル化された演算で2乗を計算
- 結果を表示するコードが含まれる

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. `exercise_square.R`として保存して実行
3. 刻み幅を0.05に変更してみる
4. 2乗以外の計算（3乗、平方根など）も試してみる

---

#### プロンプト例3: 実用的な時系列データ [★★★]

**Copilot Chatに入力**:
```
Pythonで、0から10秒まで0.01秒刻みの時刻データを作成し、
各時刻における減衰する正弦波 y = exp(-t/5) * sin(2*pi*t) を計算してください。
numpy を使い、最初の10個のデータだけ表示してください。
```

**期待される動作**:
- `np.arange()`または`np.linspace()`で時刻データを作成
- 減衰正弦波の式を実装
- 最初の10個をスライス`[:10]`で表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行
3. 減衰率（1/5）や周波数（2*pi）を変えて波形の変化を観察
4. 可能なら`matplotlib`でグラフ化してみる（発展課題）

---

### 📚 Copilot活用のコツ

1. **具体的な数値を示す**
   
   「等間隔データを作って」より「0から100まで5刻みで」のように具体的に指定すると、正確なコードが生成されます。

2. **使いたい関数名を含める**
   
   「range関数を使って」「np.linspaceで」のように、使いたい関数を明示すると、その関数を使ったコードが生成されます。

3. **結果の形式も指定する**
   
   「最初の5個だけ表示」「結果をリストで」など、出力形式も指定すると、より期待に近いコードになります。

4. **エラーが出たら質問する**
   
   生成されたコードでエラーが出たら、エラーメッセージをCopilotに見せて「このエラーを修正してください」と聞きましょう。

---

### ⚠️ 注意事項

- **終了値の扱いに注意**: Pythonの`range`は終了値を含まない、`np.arange`も浮動小数点で注意が必要
- **浮動小数点の誤差**: 0.1を10回足しても1.0にならないことがある（`np.linspace`推奨）
- **大きなデータに注意**: 100万個のデータを生成すると、メモリやCPUを大量に使います
- **importを忘れずに**: NumPyを使う場合は`import numpy as np`が必要

---

### 🎓 推奨される学習の流れ

```
1. 教材で各関数（range, seq, np.arange, np.linspace）の違いを理解
   ↓
2. サンプルプログラムで基本的な使い方を確認
   ↓
3. Copilotに「～な数値データを作って」と依頼
   ↓
4. 生成されたコードを実行して、期待通りか確認
   ↓
5. パラメータを変えて実験
   ↓
6. 実用的な応用（グラフのx軸など）に挑戦
```

**等間隔データの生成は基本中の基本です。しっかり練習しましょう！**

---

## 3.3.1.2 ファクタ（Rのみ）

> **このセクションはR言語の機能です。** Pythonには直接対応する機能はありませんが、似た概念として列挙型（enum）があります。

### ファクタとは

**ファクタ**は、限られた値（**水準**）のみを取ることができる特別なベクタです。

例えば：
- じゃんけんの手: 「グー」「チョキ」「パー」のみ
- アンケートの回答: 「はい」「いいえ」「わからない」のみ  
- 曜日: 「月」「火」「水」「木」「金」「土」「日」のみ

このように、**取りうる値があらかじめ決まっている**データに対してファクタを使います。

### ファクタの利点

1. **データの整合性**: 誤った値の入力を防げる
2. **統計解析**: カテゴリカルデータとして適切に扱える
3. **順序の管理**: 水準に順序を持たせることができる

### ファクタの作成

`factor()`関数を使って、ベクタをファクタに変換します。

#### サンプルプログラム：基本的なファクタ

**sample14_factor_basic.R**

```r
# 元になるベクタを作成
janken <- c("グー", "パー", "グー", "パー")

# ファクタに変換（水準を指定）
janken_factor <- factor(janken, levels = c("グー", "チョキ", "パー"))

# 結果を表示
print("ファクタの内容:")
print(janken_factor)

# 水準を確認
print("水準:")
print(levels(janken_factor))
```

**期待される出力**:
```
[1] "ファクタの内容:"
[1] グー パー グー パー
Levels: グー チョキ パー
[1] "水準:"
[1] "グー"   "チョキ" "パー"
```

### 水準の順序

`levels`引数で水準を指定することで、順序を定義できます。これは、グラフの表示順序などで重要になります。

#### サンプルプログラム：水準の順序

**sample15_factor_order.R**

```r
# アンケートの回答データ
responses <- c("賛成", "反対", "賛成", "どちらでもない", "賛成", "反対")

# 水準の順序を指定してファクタ化
response_factor <- factor(responses, 
                          levels = c("反対", "どちらでもない", "賛成"))

# 結果を表示
print("回答データ（ファクタ）:")
print(response_factor)

# 集計
print("集計結果:")
print(table(response_factor))
```

**期待される出力**:
```
[1] "回答データ（ファクタ）:"
[1] 賛成         反対         賛成         どちらでもない 賛成         反対        
Levels: 反対 どちらでもない 賛成
[1] "集計結果:"
response_factor
        反対 どちらでもない         賛成 
           2              1            3
```

⚠️ **注意**: 水準の順序は、表示や集計の際に影響します。論理的に意味のある順序（例：「反対→中立→賛成」）を設定しましょう。

### 水準にないデータ

元のベクタに、指定した水準にない値が含まれている場合、その値は`NA`（欠損値）になります。

#### サンプルプログラム：水準外のデータ

**sample16_factor_na.R**

```r
# 曜日データ（「祝日」が含まれている）
days <- c("月", "火", "祝日", "水")

# 通常の曜日のみを水準として指定
days_factor <- factor(days, 
                      levels = c("月", "火", "水", "木", "金", "土", "日"))

# 結果を表示
print("曜日ファクタ:")
print(days_factor)

# NAの確認
print("NAが含まれるか:")
print(any(is.na(days_factor)))
```

**期待される出力**:
```
[1] "曜日ファクタ:"
[1] 月   火   <NA> 水  
Levels: 月 火 水 木 金 土 日
[1] "NAが含まれるか:"
[1] TRUE
```

### 水準の自動設定

`levels`引数を省略すると、データに含まれる一意な値が自動的に水準になります（アルファベット順）。

#### サンプルプログラム：水準の自動設定

**sample17_factor_auto.R**

```r
# 色のデータ
colors <- c("赤", "青", "赤", "緑", "青")

# levelsを省略（自動設定）
colors_factor <- factor(colors)

# 結果を表示
print("色ファクタ:")
print(colors_factor)

print("自動設定された水準:")
print(levels(colors_factor))
```

**期待される出力**:
```
[1] "色ファクタ:"
[1] 赤 青 赤 緑 青
Levels: 青 緑 赤
[1] "自動設定された水準:"
[1] "青" "緑" "赤"
```

⚠️ **注意**: 自動設定される水準の順序は、通常アルファベット順や辞書順です。意図した順序にしたい場合は明示的に`levels`を指定しましょう。

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

ファクタは、カテゴリカルデータ（質的データ）を扱う上で重要な概念です。アンケート分析や実験データの処理で頻繁に使います。Copilotを活用して、様々なファクタの使い方を練習しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的なファクタの作成 [★☆☆]

**Copilot Chatに入力**:
```
Rで、季節（"春"、"夏"、"秋"、"冬"）のファクタを作成し、
ランダムな季節データ10個を生成して、集計するコードを書いてください。
```

**期待される動作**:
- `sample()`で季節をランダムに選択
- `factor()`でファクタ化
- `table()`で集計

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行
3. 何度か実行して、ランダム性を確認
4. データ数を変更してみる

---

#### プロンプト例2: 順序付きファクタ [★★☆]

**Copilot Chatに入力**:
```
Rで、満足度（"不満"、"普通"、"満足"）のファクタを作成し、
この順序を保ったまま集計と可視化を行うコードを書いてください。
barplotを使って棒グラフも表示してください。
```

**期待される動作**:
- `levels`で順序を指定したファクタ作成
- `table()`で集計
- `barplot()`でグラフ化

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. グラフが順序通りに表示されることを確認
3. 水準の順序を逆にしてみる
4. 他のカテゴリ（成績など）で試してみる

---

#### プロンプト例3: ファクタの変換と操作 [★★☆]

**Copilot Chatに入力**:
```
Rで、数値ベクタc(1, 2, 1, 3, 2, 1)を、
1→"低", 2→"中", 3→"高"というラベルのファクタに変換するコードを書いてください。
levels引数を使って。
```

**期待される動作**:
- `factor()`の`levels`と`labels`引数を使用
- 数値を文字列のカテゴリに変換
- 結果を表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 数値とラベルの対応を確認
3. 異なるラベル（A/B/Cなど）で試してみる
4. 数値の範囲を増やしてみる

---

### 📚 Copilot活用のコツ

1. **具体的なカテゴリを示す**
   
   「ファクタを作って」より「性別（男性、女性、その他）のファクタを作って」のように具体的に。

2. **順序の有無を明示**
   
   順序が重要な場合は「この順序で」と明示しましょう。

3. **用途を伝える**
   
   「集計用」「グラフ化用」など、目的を伝えると適切なコードが生成されます。

4. **Pythonとの比較を質問**
   
   「Pythonで同じことをするには？」と聞くと、enumやpandasのCategoricalとの比較ができます。

---

### ⚠️ 注意事項

- **水準の順序**: 指定しないと予期しない順序になることがある
- **NAの発生**: 水準にない値は自動的にNAになる
- **文字列との違い**: ファクタと文字列ベクタは異なる。必要に応じて変換が必要
- **Pythonには直接対応なし**: Pythonではpandasの`Categorical`やenumを使う

---

### 🎓 推奨される学習の流れ

```
1. ファクタの概念（水準）を理解
   ↓
2. サンプルで基本的な作成方法を確認
   ↓
3. Copilotで実用的なファクタを作成
   ↓
4. 集計やグラフ化で活用
   ↓
5. 実際のアンケートデータなどで練習
```

**ファクタはRの強力な機能です。カテゴリカルデータ分析の基本として、しっかりマスターしましょう！**

---

## 3.3.2 1次元データの演算

1次元データの真の力は、**データをまとめて計算できる**ことにあります。例えば、100個の数値すべてに同じ計算を適用したいとき、ループを書く必要はありません。1次元データなら、1行のコードで済みます。

### ベクトル化された演算の利点

**例：10個の数値をすべて2倍にする**

❌ **ループを使う場合**（冗長）:
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = []
for num in numbers:
    result.append(num * 2)
```

✅ **ベクトル化演算**（シンプル）:
```python
import numpy as np
numbers = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
result = numbers * 2
```

### NumPyアレイについて

> **Python注**: ここではNumPyの**アレイ**（`np.array`）を使います。pandasの**シリーズ**（`pd.Series`）も同じように使えます。Pythonの標準**リスト**は、このようなベクトル化演算には使えません。

NumPyは数値計算用のライブラリで、データサイエンスに不可欠です。

### スカラーとの演算

全要素に同じ数を足したり、かけたりできます。

#### サンプルプログラム：スカラー演算

**sample18_vector_scalar.R**

```r
# ベクタの作成
x <- c(2, 3, 5, 7)

# 全要素に10を加算
result_add <- x + 10

# 全要素に10を乗算
result_mul <- x * 10

# 結果を表示
print("元のベクタ:")
print(x)

print("全要素に10を加算:")
print(result_add)

print("全要素に10を乗算:")
print(result_mul)
```

**期待される出力**:
```
[1] "元のベクタ:"
[1] 2 3 5 7
[1] "全要素に10を加算:"
[1] 12 13 15 17
[1] "全要素に10を乗算:"
[1] 20 30 50 70
```

---

**sample18_array_scalar.py**

```python
import numpy as np

# アレイの作成
x = np.array([2, 3, 5, 7])

# 全要素に10を加算
result_add = x + 10

# 全要素に10を乗算
result_mul = x * 10

# 結果を表示
print("元のアレイ:")
print(x)

print("全要素に10を加算:")
print(result_add)

print("全要素に10を乗算:")
print(result_mul)
```

**期待される出力**:
```
元のアレイ:
[2 3 5 7]
全要素に10を加算:
[12 13 15 17]
全要素に10を乗算:
[20 30 50 70]
```

> **Python注**: `import numpy as np`については3.6.2項を参照。アレイは`np.array(リスト)`で作ります。

### 関数の適用

対応している関数なら、全要素にまとめて作用させられます。

#### サンプルプログラム：関数の適用

**sample19_vector_function.R**

```r
# ベクタの作成
x <- c(2, 3)

# sin関数を全要素に適用
result <- sin(x)

# 結果を表示
print("元のベクタ:")
print(x)

print("sin関数を適用:")
print(result)
```

**期待される出力**:
```
[1] "元のベクタ:"
[1] 2 3
[1] "sin関数を適用:"
[1] 0.9092974 0.1411200
```

---

**sample19_array_function.py**

```python
import numpy as np

# リストの作成（通常のリスト）
x = [2, 3]

# sin関数を全要素に適用
result = np.sin(x)

# 結果を表示
print("元のリスト:")
print(x)

print("sin関数を適用:")
print(result)
```

**期待される出力**:
```
元のリスト:
[2, 3]
sin関数を適用:
[0.90929743 0.14112001]
```

⚠️ **Python注**: `math.sin`ではなく`np.sin`を使います。`np.sin`はリストやアレイを受け取れます。

### 要素ごとの演算

要素数が同じ1次元データ同士の演算は、**位置が対応する要素ごと**に行われます。

#### サンプルプログラム：要素ごとの演算

**sample20_vector_elementwise.R**

```r
# 二つのベクタ
x <- c(2, 3, 5, 7)
y <- c(1, 10, 100, 1000)

# 要素ごとの加算
result_add <- x + y

# 要素ごとの乗算
result_mul <- x * y

# 結果を表示
print("x:")
print(x)

print("y:")
print(y)

print("x + y (要素ごとの加算):")
print(result_add)

print("x * y (要素ごとの乗算):")
print(result_mul)
```

**期待される出力**:
```
[1] "x:"
[1] 2 3 5 7
[1] "y:"
[1]    1   10  100 1000
[1] "x + y (要素ごとの加算):"
[1]    3   13  105 1007
[1] "x * y (要素ごとの乗算):"
[1]    2   30  500 7000
```

---

**sample20_array_elementwise.py**

```python
import numpy as np

# 二つのアレイ
x = np.array([2, 3, 5, 7])
y = np.array([1, 10, 100, 1000])

# 要素ごとの加算
result_add = x + y

# 要素ごとの乗算
result_mul = x * y

# 結果を表示
print("x:")
print(x)

print("y:")
print(y)

print("x + y (要素ごとの加算):")
print(result_add)

print("x * y (要素ごとの乗算):")
print(result_mul)
```

**期待される出力**:
```
x:
[2 3 5 7]
y:
[   1   10  100 1000]
x + y (要素ごとの加算):
[   3   13  105 1007]
x * y (要素ごとの乗算):
[   2   30  500 7000]
```

### 内積の計算

要素ごとに乗算した結果を合計する、つまり**内積**を計算します。

内積は、ベクトルの類似度計算や機械学習で頻繁に使われる重要な演算です。

#### サンプルプログラム：内積

**sample21_inner_product.R**

```r
# 二つのベクタ
x <- c(2, 3, 5, 7)
y <- c(1, 10, 100, 1000)

# 方法1: 要素ごとの乗算の合計
inner_product1 <- sum(x * y)

# 方法2: %*% 演算子（ほぼ同じ）
inner_product2 <- x %*% y

# 結果を表示
print("方法1（sum(x * y)）:")
print(inner_product1)

print("方法2（x %*% y）:")
print(inner_product2)
```

**期待される出力**:
```
[1] "方法1（sum(x * y)）:"
[1] 7532
[1] "方法2（x %*% y）:"
     [,1]
[1,] 7532
```

---

**sample21_inner_product.py**

```python
import numpy as np

# 二つのアレイ
x = np.array([2, 3, 5, 7])
y = np.array([1, 10, 100, 1000])

# 方法1: np.dot関数
inner_product1 = np.dot(x, y)

# 方法2: @ 演算子
inner_product2 = x @ y

# 結果を表示
print("方法1（np.dot）:")
print(inner_product1)

print("方法2（@ 演算子）:")
print(inner_product2)
```

**期待される出力**:
```
方法1（np.dot）:
7532
方法2（@ 演算子）:
7532
```

### 論理演算

論理値の1次元データに対して、要素ごとの論理演算を行います。

#### サンプルプログラム：論理演算

**sample22_logical_operations.R**

```r
# 二つの論理値ベクタ
x <- c(TRUE, FALSE)
y <- c(TRUE, TRUE)

# 要素ごとのAND
result_and <- x & y

# 要素ごとのOR
result_or <- x | y

# 結果を表示
print("x:")
print(x)

print("y:")
print(y)

print("x & y (AND):")
print(result_and)

print("x | y (OR):")
print(result_or)
```

**期待される出力**:
```
[1] "x:"
[1]  TRUE FALSE
[1] "y:"
[1] TRUE TRUE
[1] "x & y (AND):"
[1]  TRUE FALSE
[1] "x | y (OR):"
[1] TRUE TRUE
```

---

**sample22_logical_operations.py**

```python
import numpy as np

# 二つの論理値アレイ
x = np.array([True, False])
y = np.array([True, True])

# 要素ごとのAND
result_and = x & y

# 要素ごとのOR
result_or = x | y

# 結果を表示
print("x:")
print(x)

print("y:")
print(y)

print("x & y (AND):")
print(result_and)

print("x | y (OR):")
print(result_or)
```

**期待される出力**:
```
x:
[ True False]
y:
[ True  True]
x & y (AND):
[ True False]
x | y (OR):
[ True  True]
```

⚠️ **Python注**: 要素ごとの論理演算は `&`, `|`, `~` を使います。`and`, `or`, `not`ではありません。

### 比較演算

二つの1次元データ（要素数は同じ）を比較します。

#### サンプルプログラム：比較演算

**sample23_comparison.R**

```r
# 三つのベクタ
u <- c(1, 2, 3)
v <- c(1, 2, 3)
w <- c(1, 2, 4)

# 全体の比較（完全一致）
is_uv_identical <- identical(u, v)
is_uw_identical <- identical(u, w)

# 要素ごとの比較
uv_comparison <- u == v
uw_comparison <- u == w

# 結果を表示
print("u と v は完全に同じ:")
print(is_uv_identical)

print("u と w は完全に同じ:")
print(is_uw_identical)

print("u == v (要素ごと):")
print(uv_comparison)

print("u == w (要素ごと):")
print(uw_comparison)
```

**期待される出力**:
```
[1] "u と v は完全に同じ:"
[1] TRUE
[1] "u と w は完全に同じ:"
[1] FALSE
[1] "u == v (要素ごと):"
[1] TRUE TRUE TRUE
[1] "u == w (要素ごと):"
[1]  TRUE  TRUE FALSE
```

---

**sample23_comparison.py**

```python
import numpy as np

# 三つのアレイ
u = np.array([1, 2, 3])
v = np.array([1, 2, 3])
w = np.array([1, 2, 4])

# 全体の比較（すべて一致するか）
is_uv_equal = all(u == v)
is_uw_equal = all(u == w)

# 要素ごとの比較
uv_comparison = u == v
uw_comparison = u == w

# 結果を表示
print("u と v はすべて等しい:")
print(is_uv_equal)

print("u と w はすべて等しい:")
print(is_uw_equal)

print("u == v (要素ごと):")
print(uv_comparison)

print("u == w (要素ごと):")
print(uw_comparison)
```

**期待される出力**:
```
u と v はすべて等しい:
True
u と w はすべて等しい:
False
u == v (要素ごと):
[ True  True  True]
u == w (要素ごと):
[ True  True False]
```

### 比較結果を利用した集計

真（True）と偽（False）を数値として扱うと、真=1、偽=0になります。これを利用して、条件に合う要素の数や割合を求められます。

#### サンプルプログラム：比較結果の集計

**sample24_comparison_count.R**

```r
# 二つのベクタ
u <- c(1, 2, 3)
w <- c(1, 2, 4)

# 要素ごとの比較
comparison <- u == w

# 同じ要素の数（TRUEの数）
count_same <- sum(comparison)

# 同じ要素の割合
ratio_same <- mean(comparison)

# 結果を表示
print("u:")
print(u)

print("w:")
print(w)

print("u == w:")
print(comparison)

print("同じ要素の数:")
print(count_same)

print("同じ要素の割合:")
print(ratio_same)
```

**期待される出力**:
```
[1] "u:"
[1] 1 2 3
[1] "w:"
[1] 1 2 4
[1] "u == w:"
[1]  TRUE  TRUE FALSE
[1] "同じ要素の数:"
[1] 2
[1] "同じ要素の割合:"
[1] 0.6666667
```

---

**sample24_comparison_count.py**

```python
import numpy as np

# 二つのアレイ
u = np.array([1, 2, 3])
w = np.array([1, 2, 4])

# 要素ごとの比較
comparison = u == w

# 同じ要素の数（Trueの数）
count_same = comparison.sum()

# 同じ要素の割合
ratio_same = comparison.mean()

# 結果を表示
print("u:")
print(u)

print("w:")
print(w)

print("u == w:")
print(comparison)

print("同じ要素の数:")
print(count_same)

print("同じ要素の割合:")
print(ratio_same)
```

**期待される出力**:
```
u:
[1 2 3]
w:
[1 2 4]
u == w:
[ True  True False]
同じ要素の数:
2
同じ要素の割合:
0.6666666666666666
```

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

ベクトル化された演算は、データサイエンスの効率的な処理の要です。1行のコードで大量のデータを処理できる技術を、Copilotと一緒に練習しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的なベクトル演算 [★☆☆]

**Copilot Chatに入力**:
```
Pythonで、1から10までの整数のアレイを作成し、
すべての要素を2倍にして、さらに5を足した結果を表示するコードを書いてください。
numpy を使って、初心者向けにコメント付きで。
```

**期待される動作**:
- `np.arange(1, 11)`でアレイ作成
- `* 2`と`+ 5`の演算
- 結果を表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行
3. 演算の順序を変えて結果の違いを確認
4. 他の演算（割り算、累乗など）も試す

---

#### プロンプト例2: 要素ごとの演算 [★★☆]

**Copilot Chatに入力**:
```
Rで、二つのベクタ x = c(10, 20, 30) と y = c(1, 2, 3) を作成し、
要素ごとの除算（x / y）と、結果の合計を計算するコードを書いてください。
```

**期待される動作**:
- 二つのベクタを作成
- 要素ごとの除算
- `sum()`で合計

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 結果を確認（10/1 + 20/2 + 30/3 = 30になるはず）
3. ベクタの値を変えて実験
4. 平均（`mean()`）も計算してみる

---

#### プロンプト例3: 条件に合う要素の抽出 [★★★]

**Copilot Chatに入力**:
```
Pythonで、0から100までのランダムな整数10個のアレイを作成し、
50以上の要素の数と、その割合を計算するコードを書いてください。
比較演算の結果を利用して、numpy.random を使ってください。
```

**期待される動作**:
- `np.random.randint()`でランダムなアレイ作成
- `>= 50`で比較
- `.sum()`で数、`.mean()`で割合を計算

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 何度か実行してランダム性を確認
3. 条件を変更（例：30以下、70以上など）
4. 要素数を増やして大規模データで試す

---

### 📚 Copilot活用のコツ

1. **ベクトル化を意識する**
   
   「ループで」と指定すると非効率なコードが生成されます。「ベクトル演算で」と指定しましょう。

2. **NumPy/R標準関数を活用**
   
   「numpyを使って」「R標準関数で」と指定すると、適切なベクトル化されたコードが生成されます。

3. **段階的に複雑化**
   
   まず単純な演算を試し、徐々に複雑な処理に進みましょう。

4. **結果を確認する習慣**
   
   生成されたコードの結果が数学的に正しいか、自分で検算しましょう。

---

### ⚠️ 注意事項

- **要素数の一致**: 異なる長さの配列の演算は、意図しない結果を生むことがある
- **型の違い**: 整数と浮動小数点の演算では、結果の型に注意
- **論理演算の記号**: Python では `&`, `|`, `~` を使う（`and`, `or`, `not` ではない）
- **ブロードキャスト**: NumPy では自動的にサイズ調整されることがあるが、明示的に制御する方が安全

---

### 🎓 推奨される学習の流れ

```
1. スカラー演算で基本を理解
   ↓
2. 要素ごとの演算を練習
   ↓
3. Copilotで様々なパターンを試す
   ↓
4. 比較演算と論理演算を組み合わせ
   ↓
5. 実データ（成績、売上など）で応用
```

**ベクトル化された演算は、データサイエンスの基本中の基本です。しっかりマスターしましょう！**

---

## 3.3.3 複数種類のデータをひとまとめにする

これまで扱ってきた1次元データは、**同じ種類（型）のデータ**をまとめるものでした。しかし、実際のデータ処理では、**異なる型のデータ**を一緒に扱いたい場面があります。

例えば：
- ユーザー情報: ID（整数）、名前（文字列）、登録済み（論理値）
- 商品データ: 商品名（文字列）、価格（数値）、在庫あり（論理値）

このような場合に**リスト**を使います。

### RとPythonでのリストの違い

- **R**: 3.3.1項のベクタとは異なる「リスト」を使う
- **Python**: 3.3.1項と同じ「リスト」を使う（型の異なるデータを入れられる）

> **Python注**: Pythonのリストは、同じ型でも異なる型でも入れられる柔軟な仕組みです。

### リストの作成

#### サンプルプログラム：異なる型のデータ

**sample25_list_mixed.R**

```r
# 数値と文字列を含むリスト
x <- list(1, "two")

# 結果を表示
print("リストの内容:")
print(x)

# 型を確認
print("データ型:")
print(class(x))
```

**期待される出力**:
```
[1] "リストの内容:"
[[1]]
[1] 1

[[2]]
[1] "two"

[1] "データ型:"
[1] "list"
```

---

**sample25_list_mixed.py**

```python
# 数値と文字列を含むリスト
x = [1, "two"]

# 結果を表示
print("リストの内容:")
print(x)

# 型を確認
print("データ型:")
print(type(x))
```

**期待される出力**:
```
リストの内容:
[1, 'two']
データ型:
<class 'list'>
```

### 要素へのアクセス

指定した番号の要素を取り出します。

#### サンプルプログラム：要素の取り出し

**sample26_list_access.R**

```r
# リストの作成
x <- list(1, "two", TRUE)

# 2番目の要素を取り出す（2重角括弧）
element <- x[[2]]

# 結果を表示
print("2番目の要素:")
print(element)

print("その型:")
print(class(element))
```

**期待される出力**:
```
[1] "2番目の要素:"
[1] "two"
[1] "その型:"
[1] "character"
```

⚠️ **R注**: 2重の角括弧 `[[]]` を使います。1重の`[]`を使うと、リストの一部（これもリスト）が返ります。

---

**sample26_list_access.py**

```python
# リストの作成
x = [1, "two", True]

# 2番目の要素を取り出す（インデックス1）
element = x[1]

# 結果を表示
print("2番目の要素:")
print(element)

print("その型:")
print(type(element))
```

**期待される出力**:
```
2番目の要素:
two
その型:
<class 'str'>
```

### 実用例：ユーザー情報の管理

異なる型のデータをまとめて管理する実用例です。

#### サンプルプログラム：ユーザー情報

**sample27_list_userinfo.R**

```r
# ユーザー情報（ID、名前、アクティブ状態）
user <- list(
  id = 1001,
  name = "田中太郎",
  is_active = TRUE
)

# 情報を表示
print("ユーザー情報:")
print(user)

# 名前だけ取り出す
print("ユーザー名:")
print(user$name)
```

**期待される出力**:
```
[1] "ユーザー情報:"
$id
[1] 1001

$name
[1] "田中太郎"

$is_active
[1] TRUE

[1] "ユーザー名:"
[1] "田中太郎"
```

---

**sample27_list_userinfo.py**

```python
# ユーザー情報（ID、名前、アクティブ状態）
# Pythonでは辞書の方が適切（次節で詳説）
user = [1001, "田中太郎", True]

# 情報を表示
print("ユーザー情報:")
print(f"ID: {user[0]}")
print(f"名前: {user[1]}")
print(f"アクティブ: {user[2]}")
```

**期待される出力**:
```
ユーザー情報:
ID: 1001
名前: 田中太郎
アクティブ: True
```

⚠️ **Python注**: このような構造化されたデータには、次節で学ぶ**辞書**の方が適しています。

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

異なる型のデータをまとめて扱うリストは、複雑なデータ構造の基礎です。Copilotを使って、様々なデータの組み合わせを練習しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的な混合リスト [★☆☆]

**Copilot Chatに入力**:
```
Pythonで、数値、文字列、論理値を含むリストを作成し、
それぞれの要素とその型を表示するコードを書いてください。
初心者向けにコメント付きで。
```

**期待される動作**:
- 異なる型を含むリストの作成
- ループまたは個別に要素と型を表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行
3. 他の型（リスト、None など）も追加してみる
4. 各要素に対して適切な処理を考えてみる

---

#### プロンプト例2: Rのリスト操作 [★★☆]

**Copilot Chatに入力**:
```
Rで、商品情報（商品名、価格、在庫数、セール中か）を
リストとして作成し、各情報を取り出して表示するコードを書いてください。
名前付きリストとして作成してください。
```

**期待される動作**:
- `list(name = ..., price = ..., ...)`の形式
- `$`演算子で要素にアクセス
- 各情報を表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. `$`演算子と`[[]]`の両方で要素アクセスを試す
3. 新しい要素を追加してみる
4. 複数の商品でリストのリストを作ってみる（発展）

---

#### プロンプト例3: データ構造の選択 [★★☆]

**Copilot Chatに入力**:
```
Pythonで、学生情報（学籍番号、氏名、学年、GPA）を保存する方法として、
リストと辞書の両方で実装し、それぞれのメリット・デメリットを
コメントで説明してください。
```

**期待される動作**:
- リスト版と辞書版の両方を生成
- 各方法のコメント説明
- アクセス方法の違いを示す

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 両方のコードを実行して比較
3. どちらが使いやすいか考察
4. 次節（辞書）の予習になる

---

### 📚 Copilot活用のコツ

1. **用途を明確に**
   
   「商品情報を管理したい」「ユーザーデータを扱いたい」など、用途を伝えると適切な構造が提案されます。

2. **型の組み合わせを指定**
   
   「整数、文字列、論理値を含む」のように、具体的な型を示しましょう。

3. **アクセス方法も質問**
   
   「要素の取り出し方も教えて」と追加すると、より実践的なコードが得られます。

4. **より良いデータ構造を聞く**
   
   「他に良い方法はありますか？」と聞くと、辞書やクラスなど代替案を提案してくれます。

---

### ⚠️ 注意事項

- **Rの角括弧**: `[]`はリストの一部、`[[]]`は要素そのもの
- **型の混在**: 数値計算には使えない（NumPyアレイは同じ型のみ）
- **可読性**: インデックス番号だけでは何のデータか分かりにくい（辞書の方が良い場合も）
- **データ構造の選択**: 目的に応じて適切な構造を選ぶ

---

### 🎓 推奨される学習の流れ

```
1. 同じ型のデータと異なる型のデータの違いを理解
   ↓
2. サンプルで基本的なリストの使い方を確認
   ↓
3. Copilotで実用的なデータ構造を作成
   ↓
4. 次節の辞書と比較
   ↓
5. 適切なデータ構造を選択できるようになる
```

**データ構造の選択は、プログラミングの重要なスキルです。しっかり練習しましょう！**

---

## 3.3.4 文字列と値のペアのコレクション

前節では、異なる型のデータをリストでまとめました。しかし、「インデックス0は名前、1は年齢...」と覚えるのは大変です。もっと直感的に、**名前で要素にアクセス**できたら便利ですよね。

そこで使うのが：
- **R**: 名前付きリスト
- **Python**: 辞書（dictionary）

これらは、**キー（文字列）と値（value）のペア**を管理する仕組みです。

### キー・バリューの基本

**例：英単語と日本語訳の対応**
- `"apple"` → `"りんご"`
- `"orange"` → `"みかん"`

このように、キー（`"apple"`）で値（`"りんご"`）を引き出せます。

### Rの名前付きリスト

#### サンプルプログラム：基本的な名前付きリスト

**sample28_named_list.R**

```r
# 名前付きリストの作成
fruits <- list(
  apple = "りんご",
  orange = "みかん"
)

# リストの内容を表示
print("フルーツ辞書:")
print(fruits)

# 特定の要素にアクセス
print("appleの訳:")
print(fruits$apple)
```

**期待される出力**:
```
[1] "フルーツ辞書:"
$apple
[1] "りんご"

$orange
[1] "みかん"

[1] "appleの訳:"
[1] "りんご"
```

### Pythonの辞書

#### サンプルプログラム：基本的な辞書

**sample28_dictionary.py**

```python
# 辞書の作成
fruits = {
    'apple': 'りんご',
    'orange': 'みかん'
}

# 辞書の内容を表示
print("フルーツ辞書:")
print(fruits)

# 特定の要素にアクセス
print("appleの訳:")
print(fruits['apple'])
```

**期待される出力**:
```
フルーツ辞書:
{'apple': 'りんご', 'orange': 'みかん'}
appleの訳:
りんご
```

### 要素の追加

新しいキー・バリューのペアを追加します。

#### サンプルプログラム：要素の追加

**sample29_add_element.R**

```r
# 名前付きリストの作成
fruits <- list(
  apple = "りんご",
  orange = "みかん"
)

# 新しい要素を追加
fruits[["grape"]] <- "ぶどう"

# 結果を表示
print("追加後のフルーツ辞書:")
print(fruits)
```

**期待される出力**:
```
[1] "追加後のフルーツ辞書:"
$apple
[1] "りんご"

$orange
[1] "みかん"

$grape
[1] "ぶどう"
```

---

**sample29_add_element.py**

```python
# 辞書の作成
fruits = {
    'apple': 'りんご',
    'orange': 'みかん'
}

# 新しい要素を追加
fruits['grape'] = 'ぶどう'

# 結果を表示
print("追加後のフルーツ辞書:")
print(fruits)
```

**期待される出力**:
```
追加後のフルーツ辞書:
{'apple': 'りんご', 'orange': 'みかん', 'grape': 'ぶどう'}
```

### 様々なアクセス方法

キーを指定して値を取り出す方法は複数あります。

#### サンプルプログラム：複数のアクセス方法

**sample30_access_methods.R**

```r
# 名前付きリストの作成
fruits <- list(
  apple = "りんご",
  orange = "みかん"
)

# 方法1: $ 演算子
result1 <- fruits$apple

# 方法2: $"キー" の形式
result2 <- fruits$"apple"

# 方法3: [["キー"]]
result3 <- fruits[["apple"]]

# 方法4: 変数を使う
key <- "apple"
result4 <- fruits[[key]]

# 結果を表示（すべて同じ）
print(result1)
print(result2)
print(result3)
print(result4)
```

**期待される出力**:
```
[1] "りんご"
[1] "りんご"
[1] "りんご"
[1] "りんご"
```

---

**sample30_access_methods.py**

```python
# 辞書の作成
fruits = {
    'apple': 'りんご',
    'orange': 'みかん'
}

# 方法1: ['キー']
result1 = fruits['apple']

# 方法2: 変数を使う
key = 'apple'
result2 = fruits[key]

# 結果を表示（両方とも同じ）
print(result1)
print(result2)
```

**期待される出力**:
```
りんご
りんご
```

### 実用例：ユーザー情報の管理

辞書を使うと、ユーザー情報を分かりやすく管理できます。

#### サンプルプログラム：ユーザー情報（改良版）

**sample31_user_dict.R**

```r
# ユーザー情報（名前付きリスト）
user <- list(
  id = 1001,
  name = "田中太郎",
  age = 25,
  email = "tanaka@example.com",
  is_active = TRUE
)

# 情報を表示
print("ユーザー情報:")
print(paste("ID:", user$id))
print(paste("名前:", user$name))
print(paste("年齢:", user$age))
print(paste("メール:", user$email))
print(paste("アクティブ:", user$is_active))
```

**期待される出力**:
```
[1] "ユーザー情報:"
[1] "ID: 1001"
[1] "名前: 田中太郎"
[1] "年齢: 25"
[1] "メール: tanaka@example.com"
[1] "アクティブ: TRUE"
```

---

**sample31_user_dict.py**

```python
# ユーザー情報（辞書）
user = {
    'id': 1001,
    'name': '田中太郎',
    'age': 25,
    'email': 'tanaka@example.com',
    'is_active': True
}

# 情報を表示
print("ユーザー情報:")
print(f"ID: {user['id']}")
print(f"名前: {user['name']}")
print(f"年齢: {user['age']}")
print(f"メール: {user['email']}")
print(f"アクティブ: {user['is_active']}")
```

**期待される出力**:
```
ユーザー情報:
ID: 1001
名前: 田中太郎
年齢: 25
メール: tanaka@example.com
アクティブ: True
```

> **Python注**: Pythonの辞書は、文字列以外の（変更不可能な）ものもキーとして使えますが、通常は文字列を使います。

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

キー・バリュー型のデータ構造は、実際のアプリケーション開発で非常によく使われます。ユーザー情報、設定データ、API レスポンスなど、様々な場面で活躍します。Copilotを使って実践的な使い方を学びましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 基本的な辞書操作 [★☆☆]

**Copilot Chatに入力**:
```
Pythonで、商品情報（商品名、価格、カテゴリ、在庫数）を
辞書として作成し、各情報を分かりやすく表示するコードを書いてください。
初心者向けにコメント付きで。
```

**期待される動作**:
- 辞書の作成
- 各キーで値にアクセス
- f-stringで整形して表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードを実行
3. 商品情報を変更してみる
4. 新しいキー（例：「メーカー」）を追加してみる

---

#### プロンプト例2: 複数のレコード管理 [★★☆]

**Copilot Chatに入力**:
```
Rで、3人の学生情報（学籍番号、氏名、学年）を
名前付きリストのリストとして管理し、
各学生の情報を表示するコードを書いてください。
```

**期待される動作**:
- リストの中にリストを入れる構造
- 各学生情報にアクセス
- ループで全員の情報を表示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. データ構造を理解する
3. 新しい学生を追加してみる
4. 特定の学年の学生だけ表示するコードを追加（発展）

---

#### プロンプト例3: 設定ファイル的な使い方 [★★★]

**Copilot Chatに入力**:
```
Pythonで、アプリケーション設定を辞書で管理するコードを書いてください。
設定項目は以下:
- データベース接続情報（ホスト、ポート、ユーザー名）
- ログ設定（レベル、出力先）
- 機能フラグ（新機能有効/無効）

設定を読み込んで使う例も示してください。
```

**期待される動作**:
- ネストした辞書（辞書の中に辞書）
- 各設定にアクセスする例
- 実用的な構造

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. ネストした辞書の構造を理解
3. 設定を変更して動作を確認
4. JSONファイルから読み込む方法も聞いてみる（発展）

---

### 📚 Copilot活用のコツ

1. **キーは意味のある名前に**
   
   「キーを分かりやすい名前で」と指定すると、可読性の高いコードが生成されます。

2. **実用的なシナリオで質問**
   
   「○○を管理したい」と具体的な用途を示すと、適切な構造が提案されます。

3. **アクセス方法も聞く**
   
   「値の取得方法も」「すべてのキーを表示する方法も」など、操作方法も併せて質問しましょう。

4. **エラー処理も聞いてみる**
   
   「存在しないキーへのアクセス時の対処法は？」と聞くと、より堅牢なコードが得られます（発展）。

---

### ⚠️ 注意事項

- **Rのアクセス方法**: `$`と`[[]]`で微妙に動作が異なる場合がある
- **キーの存在確認**: 存在しないキーにアクセスするとエラーになる
- **キーの命名**: スペースや記号は避け、分かりやすい名前を付ける
- **ネスト構造**: 深くネストしすぎると複雑になる

---

### 🎓 推奨される学習の流れ

```
1. キー・バリューの概念を理解
   ↓
2. サンプルで基本的な作成とアクセスを確認
   ↓
3. Copilotで実用的な辞書を作成
   ↓
4. 複数のレコード管理に挑戦
   ↓
5. 実際のデータ（JSON等）と連携（発展）
```

**辞書/名前付きリストは、データ管理の基本です。しっかりマスターしましょう！**

---

## 3.3.5 補足:コピーと参照

RとPythonの最も重要な違いの一つが、**変数への割り当て**の動作です。この違いを理解していないと、思わぬバグに遭遇します。

### 割り当ての違い

- **R**: `y <- x` とすると、`x`の**コピー**が`y`になる
- **Python**: `y = x` とすると、`y`は`x`と**同じもの**を指す

### Rでの動作：コピー

#### サンプルプログラム：Rのコピー動作

**sample32_copy_r.R**

```r
# 元のベクタ
x <- c("foo", "bar", "baz")

# yにxを割り当て
y <- x

# yを更新
y[2] <- "BAR"

# 結果を表示
print("y（更新後）:")
print(y)

print("x（変わらない）:")
print(x)
```

**期待される出力**:
```
[1] "y（更新後）:"
[1] "foo" "BAR" "baz"
[1] "x（変わらない）:"
[1] "foo" "bar" "baz"
```

**説明**: `y <- x`の時点で`x`のコピーが作られるため、`y`を変更しても`x`は影響を受けません。

### Pythonでの動作：参照

#### サンプルプログラム：Pythonの参照動作

**sample32_reference_python.py**

```python
# 元のリスト
x = ['foo', 'bar', 'baz']

# yにxを割り当て
y = x

# yを更新
y[1] = 'BAR'

# 結果を表示
print("y（更新後）:")
print(y)

print("x（yと同じものなので、変わる！）:")
print(x)
```

**期待される出力**:
```
y（更新後）:
['foo', 'BAR', 'baz']
x（yと同じものなので、変わる！）:
['foo', 'BAR', 'baz']
```

**説明**: `y = x`では、`x`と`y`が**同じオブジェクト**を指すようになります。したがって、`y`を更新すると`x`も変わります。

### 図解：RとPythonの違い

**R の場合**:
```
y <- x を実行
┌─────┐         ┌─────────────────┐
│  x  │ ──────→ │ foo, bar, baz   │  元のデータ
└─────┘         └─────────────────┘
                         ↓ コピー
┌─────┐         ┌─────────────────┐
│  y  │ ──────→ │ foo, bar, baz   │  新しいコピー
└─────┘         └─────────────────┘
```

**Python の場合**:
```
y = x を実行
┌─────┐    
│  x  │ ─────┐
└─────┘      ↓
           ┌─────────────────┐
           │ foo, bar, baz   │  同じデータを両方が指す
           └─────────────────┘
┌─────┐      ↑
│  y  │ ─────┘
└─────┘
```

### Pythonでコピーを作る方法

Pythonでも、Rのようにコピーを作ることができます。

#### サンプルプログラム：Pythonでのコピー

**sample33_copy_python.py**

```python
# 元のリスト
x = ['foo', 'bar', 'baz']

# copy()メソッドでコピーを作成
y = x.copy()

# xとyの関係を確認
print("xとyは等価（内容は同じ）:", x == y)
print("xとyは同一（同じオブジェクト）:", x is y)

# yを更新
y[1] = 'BAR'

# 結果を表示
print("\ny（更新後）:")
print(y)

print("x（変わらない）:")
print(x)
```

**期待される出力**:
```
xとyは等価（内容は同じ）: True
xとyは同一（同じオブジェクト）: False

y（更新後）:
['foo', 'BAR', 'baz']
x（変わらない）:
['foo', 'bar', 'baz']
```

### 等価 vs 同一

Pythonには2種類の「同じ」があります：

- **等価**（`==`）: 内容が同じ
- **同一**（`is`）: 同じオブジェクト

#### サンプルプログラム：等価と同一の違い

**sample34_equality_identity.py**

```python
# 二つのリスト
x = ['foo', 'bar', 'baz']
y = x           # 参照
z = x.copy()    # コピー

# 等価性のチェック（内容が同じか）
print("x == y:", x == y)  # True（同じ内容）
print("x == z:", x == z)  # True（同じ内容）

# 同一性のチェック（同じオブジェクトか）
print("x is y:", x is y)  # True（同じオブジェクト）
print("x is z:", x is z)  # False（別のオブジェクト）

# yを更新すると...
y[0] = 'FOO'

print("\ny更新後:")
print("x:", x)  # xも変わる（同一だから）
print("z:", z)  # zは変わらない（別物だから）
```

**期待される出力**:
```
x == y: True
x == z: True
x is y: True
x is z: False

y更新後:
x: ['FOO', 'bar', 'baz']
z: ['foo', 'bar', 'baz']
```

### Rの詳細：コピーオンライト

> **R上級者向けの補足**: 
> 
> 厳密には、Rでコピーが作られるのは「`y <- x`」のときではなく、「`y[2] <- "BAR"`」のときです（コピーオンライト）。
>
> これは`pryr::address()`関数で確認できます。

---

## 💡 GitHub Copilot活用ガイド

### このセクションで学んだことをCopilotで実践

コピーと参照の違いは、バグの原因になりやすい重要なポイントです。Copilotを使って、この違いを実験的に理解しましょう。

### 🚀 使えるプロンプト例

#### プロンプト例1: 参照の動作確認 [★☆☆]

**Copilot Chatに入力**:
```
Pythonで、リストの参照の動作を確認するコードを書いてください。
元のリストxに対して、y = x とした後、yを変更すると
xも変わることを示してください。途中の状態も表示してください。
```

**期待される動作**:
- 参照の割り当て
- 変更前後でxとyの両方を表示
- 同じオブジェクトであることの確認

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 生成されたコードで動作を確認
3. 数値のリストでも試してみる
4. 辞書でも同じ動作になるか確認

---

#### プロンプト例2: コピーの作成 [★★☆]

**Copilot Chatに入力**:
```
Pythonで、リストのコピーを作成する3つの方法
（copy()メソッド、スライス、list()関数）を示し、
それぞれでコピーが正しく作られることを確認するコードを書いてください。
```

**期待される動作**:
- 3つの異なるコピー方法
- 各方法で作ったコピーを変更
- 元のリストが変わらないことを確認

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. 3つの方法を理解する
3. どの方法が最も分かりやすいか考える
4. ネストしたリスト（リストの中のリスト）でも試してみる（深いコピーの問題）

---

#### プロンプト例3: 実践的なデバッグ [★★★]

**Copilot Chatに入力**:
```
Pythonで、参照の問題によるバグの例を示し、
それをコピーで修正するコードを書いてください。
例えば、関数内でリストを変更したら、
呼び出し元のリストも変わってしまう問題など。
```

**期待される動作**:
- バグのある版（参照を使った問題）
- 修正版（コピーを使った解決）
- 両方の動作の違いを明示

**やってみよう**:
1. Copilot Chatに上記のプロンプトを入力
2. バグのパターンを理解する
3. 自分のコードで同じ問題が起きていないかチェック
4. 他のバグパターンも質問してみる

---

### 📚 Copilot活用のコツ

1. **実験的なコードを書いてもらう**
   
   「～を確認するコードを書いて」と依頼すると、学習に適したコードが生成されます。

2. **比較を依頼**
   
   「参照とコピーの違いを示すコードを書いて」のように、比較するコードを依頼しましょう。

3. **バグの例を聞く**
   
   「よくあるバグのパターンは？」と聞くと、実践的な知識が得られます。

4. **Rとの比較を質問**
   
   「Rではどうなりますか？」と聞くと、言語間の違いが明確になります。

---

### ⚠️ 注意事項

- **ネストした構造**: リストの中のリストなど、ネストした構造では浅いコピー（`.copy()`）だけでは不十分な場合がある
- **変更不可能なオブジェクト**: 文字列や数値などは参照でも問題ない（変更できないため）
- **関数の引数**: Pythonの関数にリストを渡すと参照が渡される
- **Rのコピーオンライト**: Rも完全に毎回コピーするわけではなく、必要時にコピーする

---

### 🎓 推奨される学習の流れ

```
1. RとPythonの割り当ての違いを理解
   ↓
2. サンプルで動作を確認
   ↓
3. Copilotで様々なパターンを実験
   ↓
4. バグのパターンを学ぶ
   ↓
5. 自分のコードで注意して使う
```

**コピーと参照の違いは、初心者がつまずきやすいポイントです。しっかり理解しましょう！**

---

## 3.3.6 統合演習

これまで学んだコレクションの知識を統合して、実践的な課題に取り組みましょう。

### 演習課題1：学生成績管理システム

#### 課題の目的
複数の学生の試験成績を管理し、統計情報を計算するプログラムを作成します。

#### 要件

**データ**:
- 5人の学生の情報（学籍番号、氏名、3科目の成績）

**処理**:
1. 各学生の平均点を計算
2. 各科目の平均点を計算
3. 最高点と最低点の学生を特定
4. 60点以上の学生の割合を計算

**出力形式**:
```
=== 学生成績管理システム ===

学生情報:
S001: 田中太郎 - 数学: 85, 英語: 78, 国語: 92
S002: 鈴木花子 - 数学: 92, 英語: 88, 国語: 85
...

統計情報:
各科目の平均点:
  数学: XX.X点
  英語: XX.X点
  国語: XX.X点

最高平均点: 鈴木花子 (XX.X点)
最低平均点: ... (XX.X点)

合格者（平均60点以上）の割合: XX.X%
```

#### データ例

**R版用データ**:
```r
# 学生データ（リストのリスト）
students <- list(
  list(id = "S001", name = "田中太郎", math = 85, english = 78, japanese = 92),
  list(id = "S002", name = "鈴木花子", math = 92, english = 88, japanese = 85),
  list(id = "S003", name = "佐藤次郎", math = 78, english = 82, japanese = 76),
  list(id = "S004", name = "高橋美咲", math = 88, english = 90, japanese = 94),
  list(id = "S005", name = "伊藤健太", math = 72, english = 68, japanese = 70)
)
```

**Python版用データ**:
```python
# 学生データ（辞書のリスト）
students = [
    {'id': 'S001', 'name': '田中太郎', 'math': 85, 'english': 78, 'japanese': 92},
    {'id': 'S002', 'name': '鈴木花子', 'math': 92, 'english': 88, 'japanese': 85},
    {'id': 'S003', 'name': '佐藤次郎', 'math': 78, 'english': 82, 'japanese': 76},
    {'id': 'S004', 'name': '高橋美咲', 'math': 88, 'english': 90, 'japanese': 94},
    {'id': 'S005', 'name': '伊藤健太', 'math': 72, 'english': 68, 'japanese': 70}
]
```

#### ヒント

1. **平均の計算**: NumPy の`mean()`やRの`mean()`を活用
2. **ループ処理**: 各学生について繰り返し処理
3. **最大・最小**: 比較しながら追跡
4. **条件カウント**: 論理演算の結果を利用

#### 提出形式
- Rファイル: `exercise01_grade_system.R`
- Pythonファイル: `exercise01_grade_system.py`
- 両方のファイルを作成し、同じ結果が得られることを確認

---

### 演習課題2：商品在庫管理システム

#### 課題の目的
商品の在庫データを管理し、在庫状況を分析するプログラムを作成します。

#### 要件

**データ**:
- 商品情報（商品ID、商品名、価格、在庫数、カテゴリ）

**処理**:
1. 在庫切れ（在庫0）の商品をリストアップ
2. カテゴリ別の在庫総額を計算
3. 最も高額な商品と最も安価な商品を特定
4. 在庫数が5個以下の商品の警告リスト作成

**出力形式**:
```
=== 商品在庫管理システム ===

在庫切れ商品:
- P003: 商品C

カテゴリ別在庫総額:
- 電子機器: XXX,XXX円
- 文房具: XXX,XXX円

最高額商品: 商品X (XX,XXX円)
最安値商品: 商品Y (XXX円)

在庫警告（5個以下）:
- P001: 商品A (残り3個)
- P004: 商品D (残り2個)
```

#### データ例

**R版用データ**:
```r
products <- list(
  list(id = "P001", name = "ノートPC", price = 89800, stock = 3, category = "電子機器"),
  list(id = "P002", name = "マウス", price = 1980, stock = 15, category = "電子機器"),
  list(id = "P003", name = "キーボード", price = 5980, stock = 0, category = "電子機器"),
  list(id = "P004", name = "ノート", price = 198, stock = 2, category = "文房具"),
  list(id = "P005", name = "ペン", price = 120, stock = 50, category = "文房具")
)
```

**Python版用データ**:
```python
products = [
    {'id': 'P001', 'name': 'ノートPC', 'price': 89800, 'stock': 3, 'category': '電子機器'},
    {'id': 'P002', 'name': 'マウス', 'price': 1980, 'stock': 15, 'category': '電子機器'},
    {'id': 'P003', 'name': 'キーボード', 'price': 5980, 'stock': 0, 'category': '電子機器'},
    {'id': 'P004', 'name': 'ノート', 'price': 198, 'stock': 2, 'category': '文房具'},
    {'id': 'P005', 'name': 'ペン', 'price': 120, 'stock': 50, 'category': '文房具'}
]
```

#### ヒント

1. **条件抽出**: リストから条件に合う要素を探す
2. **グループ化**: カテゴリごとに集計
3. **在庫総額**: 価格 × 在庫数の合計

#### 提出形式
- Rファイル: `exercise02_inventory_system.R`
- Pythonファイル: `exercise02_inventory_system.py`

---

### 評価基準

各課題について：

#### 基本要件（60点）
- [ ] プログラムが正常に実行される
- [ ] すべての要件を満たしている
- [ ] 出力が指定された形式に従っている

#### コードの質（20点）
- [ ] 適切なコメントがある
- [ ] 変数名が分かりやすい
- [ ] コードが読みやすく整理されている

#### 発展的要素（20点）
- [ ] エラー処理や入力チェックがある（発展版）
- [ ] 追加の統計情報や機能を実装している
- [ ] コードの効率性や汎用性が考慮されている

---

### 解答例（基本版）

以下は課題1の解答例です。参考にしてください。

#### R版解答例

**exercise01_grade_system_answer.R**

```r
# 学生データ
students <- list(
  list(id = "S001", name = "田中太郎", math = 85, english = 78, japanese = 92),
  list(id = "S002", name = "鈴木花子", math = 92, english = 88, japanese = 85),
  list(id = "S003", name = "佐藤次郎", math = 78, english = 82, japanese = 76),
  list(id = "S004", name = "高橋美咲", math = 88, english = 90, japanese = 94),
  list(id = "S005", name = "伊藤健太", math = 72, english = 68, japanese = 70)
)

# タイトル
print("=== 学生成績管理システム ===")
print("")

# 学生情報の表示と平均点の計算
print("学生情報:")
averages <- c()
for (student in students) {
  avg <- mean(c(student$math, student$english, student$japanese))
  averages <- c(averages, avg)
  print(sprintf("%s: %s - 数学: %d, 英語: %d, 国語: %d (平均: %.1f)",
                student$id, student$name, 
                student$math, student$english, student$japanese, avg))
}
print("")

# 各科目の平均点
math_scores <- c()
english_scores <- c()
japanese_scores <- c()
for (student in students) {
  math_scores <- c(math_scores, student$math)
  english_scores <- c(english_scores, student$english)
  japanese_scores <- c(japanese_scores, student$japanese)
}

print("統計情報:")
print(sprintf("数学の平均: %.1f点", mean(math_scores)))
print(sprintf("英語の平均: %.1f点", mean(english_scores)))
print(sprintf("国語の平均: %.1f点", mean(japanese_scores)))
print("")

# 最高・最低平均点の学生
max_index <- which.max(averages)
min_index <- which.min(averages)
print(sprintf("最高平均点: %s (%.1f点)", 
              students[[max_index]]$name, averages[max_index]))
print(sprintf("最低平均点: %s (%.1f点)", 
              students[[min_index]]$name, averages[min_index]))
print("")

# 合格者の割合
pass_count <- sum(averages >= 60)
pass_rate <- pass_count / length(averages) * 100
print(sprintf("合格者（平均60点以上）: %d人 (%.1f%%)", pass_count, pass_rate))
```

#### Python版解答例

**exercise01_grade_system_answer.py**

```python
import numpy as np

# 学生データ
students = [
    {'id': 'S001', 'name': '田中太郎', 'math': 85, 'english': 78, 'japanese': 92},
    {'id': 'S002', 'name': '鈴木花子', 'math': 92, 'english': 88, 'japanese': 85},
    {'id': 'S003', 'name': '佐藤次郎', 'math': 78, 'english': 82, 'japanese': 76},
    {'id': 'S004', 'name': '高橋美咲', 'math': 88, 'english': 90, 'japanese': 94},
    {'id': 'S005', 'name': '伊藤健太', 'math': 72, 'english': 68, 'japanese': 70}
]

# タイトル
print("=== 学生成績管理システム ===")
print()

# 学生情報の表示と平均点の計算
print("学生情報:")
averages = []
for student in students:
    scores = [student['math'], student['english'], student['japanese']]
    avg = np.mean(scores)
    averages.append(avg)
    print(f"{student['id']}: {student['name']} - " 
          f"数学: {student['math']}, 英語: {student['english']}, "
          f"国語: {student['japanese']} (平均: {avg:.1f})")
print()

# 各科目の平均点
math_scores = [s['math'] for s in students]
english_scores = [s['english'] for s in students]
japanese_scores = [s['japanese'] for s in students]

print("統計情報:")
print(f"数学の平均: {np.mean(math_scores):.1f}点")
print(f"英語の平均: {np.mean(english_scores):.1f}点")
print(f"国語の平均: {np.mean(japanese_scores):.1f}点")
print()

# 最高・最低平均点の学生
max_index = np.argmax(averages)
min_index = np.argmin(averages)
print(f"最高平均点: {students[max_index]['name']} ({averages[max_index]:.1f}点)")
print(f"最低平均点: {students[min_index]['name']} ({averages[min_index]:.1f}点)")
print()

# 合格者の割合
averages_array = np.array(averages)
pass_count = np.sum(averages_array >= 60)
pass_rate = pass_count / len(averages) * 100
print(f"合格者（平均60点以上）: {pass_count}人 ({pass_rate:.1f}%)")
```

---

## 3.3.7 本節のまとめ

### 学んだこと

この節では、データをひとまとめにする「コレクション」について学びました。

#### 1次元データ
- **R**: ベクタ（`c()`で作成）
- **Python**: リスト（`[]`で作成）、アレイ（`np.array()`）
- **重要な違い**: インデックスはRが1始まり、Pythonが0始まり

#### 等間隔データの生成
- **R**: `seq()`, `rep()`, `:`演算子
- **Python**: `range()`, `np.arange()`, `np.linspace()`
- **用途**: グラフ作成、シミュレーション、時系列データ

#### ファクタ（Rのみ）
- カテゴリカルデータを扱う仕組み
- 水準（levels）の概念
- アンケート分析や実験データで活用

#### ベクトル化された演算
- スカラー演算：全要素に同じ値を適用
- 要素ごとの演算：対応する位置同士で計算
- 内積、論理演算、比較演算
- **利点**: ループ不要で高速・簡潔

#### 複数種類のデータ
- **R**: リスト（`list()`）
- **Python**: リスト（型の異なるデータも格納可能）
- **用途**: 構造化されたデータの管理

#### キー・バリュー型
- **R**: 名前付きリスト（`list(name = value)`）
- **Python**: 辞書（`{key: value}`）
- **利点**: 名前で要素にアクセスでき、可読性が高い

#### コピーと参照
- **R**: 割り当て時にコピーが作られる
- **Python**: 割り当ては参照（同じオブジェクトを指す）
- **Pythonでコピー**: `.copy()`メソッドを使用
- **重要**: この違いを理解しないとバグの原因に

### 次節への展望

3.4節では、データサイエンスで最も重要な**データフレーム**を学びます。データフレームは：
- 表形式のデータを扱う
- 複数の列（変数）を持つ
- この節で学んだコレクションの知識が基礎になる

コレクションの理解を深めることで、データフレームの学習がスムーズになります。

### 重要ポイントの復習

1. **インデックスの違い**
   - Rは1から、Pythonは0から
   - 負のインデックスの動作も異なる

2. **ベクトル化演算の威力**
   - ループを書かずにデータ処理
   - 高速で簡潔なコード

3. **適切なデータ構造の選択**
   - 同じ型 → ベクタ/アレイ
   - 異なる型 → リスト
   - キー・バリュー → 名前付きリスト/辞書

4. **コピーと参照**
   - Pythonでは意図しない変更に注意
   - 必要に応じて`.copy()`を使用

### 実践へのステップ

このセクションで学んだコレクションは、データサイエンスのあらゆる場面で使います：
- データの前処理
- 統計計算
- 機械学習のデータ準備
- 結果の可視化

しっかり復習して、次のステップに進みましょう！

---

## 3.3.8 自己チェックリスト

本節の内容を理解できたか、以下のチェックリストで確認しましょう。

### A. 環境構築と基本操作

- [ ] VS Codeで`.R`ファイルと`.py`ファイルを作成できる
- [ ] `Rscript ファイル名.R`でRプログラムを実行できる
- [ ] `python ファイル名.py`でPythonプログラムを実行できる
- [ ] `touch`コマンドでファイルを作成できる
- [ ] VS CodeのターミナルでWSL環境を使える
- [ ] GitHub Copilotが有効になっていることを確認できる
- [ ] GitHub Copilot Chatを起動できる

### B. プログラミング基礎スキル

#### 1次元データ（3.3.1）
- [ ] Rで`c()`を使ってベクタを作成できる
- [ ] Pythonで`[]`を使ってリストを作成できる
- [ ] `length()`（R）と`len()`（Python）で要素数を取得できる
- [ ] インデックスを使って要素にアクセスできる
- [ ] RとPythonでインデックスの開始番号（1 vs 0）の違いを理解している
- [ ] 要素を更新できる
- [ ] 負のインデックスの動作の違い（R vs Python）を理解している
- [ ] 新しい要素を追加できる

#### 等間隔データ（3.3.1.1）
- [ ] Rで`:`演算子を使って連続整数を作成できる
- [ ] Pythonで`range()`を使って連続整数を作成できる
- [ ] Rで`seq()`を使って等間隔データを作成できる
- [ ] Pythonで`np.arange()`を使って等間隔データを作成できる
- [ ] Pythonで`np.linspace()`を使って要素数指定のデータを作成できる
- [ ] Rで`rep()`、Pythonで`[値] * n`を使って同じ値を繰り返せる
- [ ] `range()`と`np.arange()`の終了値の扱いの違いを理解している

#### ファクタ（3.3.1.2）
- [ ] Rで`factor()`を使ってファクタを作成できる
- [ ] 水準（levels）の概念を理解している
- [ ] `levels`引数で水準の順序を指定できる
- [ ] ファクタの用途（カテゴリカルデータ）を理解している
- [ ] 水準にない値が`NA`になることを理解している

#### 1次元データの演算（3.3.2）
- [ ] NumPyをインポートできる（`import numpy as np`）
- [ ] Pythonで`np.array()`を使ってアレイを作成できる
- [ ] ベクタ/アレイに対してスカラー演算（加算、乗算など）ができる
- [ ] 関数（`sin`など）を全要素に適用できる
- [ ] 要素ごとの演算（加算、乗算など）ができる
- [ ] 内積を計算できる（`sum(x*y)`、`np.dot(x,y)`、`x@y`など）
- [ ] 要素ごとの論理演算ができる（`&`, `|`, `~`）
- [ ] PythonでNumPy演算に`&`, `|`, `~`を使う（`and`, `or`, `not`ではない）ことを理解している
- [ ] 1次元データ同士を比較できる
- [ ] 比較結果を利用して条件に合う要素の数や割合を計算できる
- [ ] ベクトル化演算の利点（ループ不要、高速、簡潔）を理解している

#### 複数種類のデータ（3.3.3）
- [ ] Rで異なる型を含むリストを作成できる
- [ ] Pythonで異なる型を含むリストを作成できる
- [ ] Rで2重角括弧`[[]]`を使って要素にアクセスできる
- [ ] Rで`[]`と`[[]]`の違いを理解している

#### キー・バリュー型（3.3.4）
- [ ] Rで名前付きリストを作成できる
- [ ] Pythonで辞書を作成できる
- [ ] Rで`$`演算子を使って要素にアクセスできる
- [ ] Pythonで`['キー']`を使って要素にアクセスできる
- [ ] 新しいキー・バリューのペアを追加できる
- [ ] Rで複数のアクセス方法（`$`, `$"キー"`, `[["キー"]]`）を使える
- [ ] 辞書/名前付きリストの用途（構造化データ）を理解している

#### コピーと参照（3.3.5）
- [ ] Rで割り当て（`y <- x`）がコピーを作ることを理解している
- [ ] Pythonで割り当て（`y = x`）が参照になることを理解している
- [ ] Pythonで`.copy()`メソッドを使ってコピーを作成できる
- [ ] Pythonで等価（`==`）と同一（`is`）の違いを理解している
- [ ] コピーと参照の違いによるバグを避けられる
- [ ] Rのコピーオンライト（COW）の概念を知っている（上級者向け）

### C. AI協働スキル

- [ ] GitHub Copilot Chatに効果的なプロンプトを書ける
- [ ] Copilotに具体的な条件（「初心者向け」「コメント付き」など）を指定できる
- [ ] 生成されたコードを理解してから使用している
- [ ] Copilotの提案を鵜呑みにせず、検証している
- [ ] 困ったときにCopilotに質問できる
- [ ] Copilotを「学習パートナー」として活用している
- [ ] コメントを先に書いてCopilotに補完させる方法を使える
- [ ] Copilotに「他の方法は？」と質問して複数の解決策を得られる

### D. 概念理解

- [ ] コレクションの必要性と利点を説明できる
- [ ] 1次元データの概念を理解している
- [ ] ベクトル化演算の利点を説明できる
- [ ] ファクタ（水準）の用途を説明できる
- [ ] 適切なデータ構造（ベクタ/リスト/辞書）を選択できる
- [ ] キー・バリュー型の利点を説明できる
- [ ] RとPythonのコピーと参照の違いを説明できる
- [ ] NumPyアレイとPythonリストの違いを理解している
- [ ] 各コレクションの使い分けができる

### E. 課題完遂

- [ ] 演習課題1（学生成績管理システム）を完了した
- [ ] 演習課題2（商品在庫管理システム）を完了した（オプション）
- [ ] RとPythonの両方で同じ結果が得られることを確認した
- [ ] プログラムが正常に実行されることを確認した
- [ ] 自分なりの改良や追加機能を実装してみた（オプション）

---

### 📊 達成度評価

チェックした項目の数を数えましょう。

- **70項目以上**: 🌟🌟🌟 優秀！次の節に進む準備ができています
- **55-69項目**: 🌟🌟 良好！不安な部分を復習しましょう
- **40-54項目**: 🌟 合格！重要なポイントを重点的に復習しましょう
- **39項目以下**: もう一度教材を読み直し、サンプルを実行してみましょう

---

### 🔄 復習のポイント

チェックできなかった項目について：

1. **該当セクションを読み直す**
2. **サンプルプログラムを自分で実行する**
3. **GitHub Copilotに質問して理解を深める**
4. **演習問題で実践する**
5. **わからない部分は教員やTAに質問する**

---

### 🎯 次のステップ

全項目をチェックできたら：

1. **3.4節「データフレーム」に進む準備ができています**
2. **余裕があれば、発展的な課題に挑戦しましょう**
3. **実際のデータセットでコレクションを活用してみましょう**

---

**お疲れ様でした！コレクションの基礎をしっかりマスターできましたね。次はデータサイエンスの核心、データフレームに進みましょう！** 🚀📊
